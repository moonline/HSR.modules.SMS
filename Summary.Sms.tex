%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary SMS}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{commands/shortcutsListAndChapter}
\input{commands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}

% Inhaltsverzeichnis
\tableofcontents
\clearpage

\ch{Einführung}

\ul
	\li Variabilitäten sind in Projeten immer enthalten
	\li Wenn ich gewisse Auftrittswahrscheinlichkeiten für Störungen habe, so lässte sich ein ganzer ABlauf nicht mehr einfach berechnen.
	\li Simulation ist ein Versuch, Variablität in den Griff zu bekommen.
\ulE

\se{Projektabhängigkeiten}
\ul
	\li Prozesse sollten nicht als gekapselte Systeme betrachtet werden
	\li Alle Systeme besitzen Abhängigkeiten
	\li Bevor die Simulation starten kann, muss das System inkl. die Abhänggkeiten verstanden sein
\ulE

\se{Anwendung Simulation}
\ul
	\li Wenn System noch gar nicht vorhanden ist
	\li Wenn ausprobieren zu gefährlich ist
	\li Wenn Testen zu teuer ist
\ulE

\se{Einsatzzwecke Simulation}
\ul
	\li Analyse von Zeitlichem Verhalten von Systemen
\ulE

\se{Komplexität}
\ul
	\li Simulation kann mit Projektkomplexität umgehen
\ulE

\se{Was ist Simulation?}
\ul
	\li Entwicklung eines Modells eines konkreten Systems
	\li Durchführen von Experimenten mit diesem System
\ulE

\expl{System}{
\ul
	\li Hat definierte Grenzen
	\li Lässt sich runterbrechen in Subsysteme
	\li Reale Systeme: Komplexe oder hybernetische Systeme
\ulE}

\expl{Model}{Abstraktion der Wirklichkeit und deren Funktion. Experimentieren mit dem Modell ist möglich, ohne das Ursprungssystem zu zerstören.}

\expl{Experiment}{Ausprobieren eines Ablaufes mit bestimmten Parametern. Unterliegen immer Streuungen. Zur Simulation von Streuungen sind empirische Daten oder Zufallszahlen notwendig.}

\img{img/v1.1.jpg}{}{0.75}{}

\se{Repetition}
\sse{Warum Simulation}
\ul
	\li Dinge, die nicht berechenbar sind
	\li Dinge, die wir nicht ausprobieren möchten
\ulE

\sse{Diskrete und kontinuierlich Simulation}
\ul
	\li Diskrete Simulation: Zustandswechsel / Übergäge sind Eventbasiert und in zeitlichen Intervallen \\ Zusandsübergänge interessieren uns nicht
	\li Kontinuierliche Sumulation: Zusandswechsel sind kontinuierlich, \\Zustandswechsel/Übergang interessieren,\\ bsp. physikalische Vorgänge wie Crashsimulation
\ulE

\sse{dynamische und statische Simulation}
\ul
	\li statisch: kein Änderung über der Zeit, \\ bsp. Spreadsheetsimulation, SPS-Simulation aller Zustände
	\li dynamisch: System ändert sich über der Zeit
\ulE

\sse{Systemsprünge}
\ul
	\li Equidistante Systemsprünge: Alle Systemwechsel fallen in ein Delta-t
\ulE


\ch{Anwendungsbereiche}
Modellbildung ist immer Zielgerichtet: Was für Fragen sollen beantwortet werden
\ul
	\li Flaschenhälse in Abläufen
	\li Rosourcen Planung
	\li Neusystem Entwicklung
	\li Änderungen an bestehenden Systemen
\ulE

\sse{Key Performance Indicators KPI}
\ul
	\li  Resource utilizations
 	\li Total throughput
 	\li Work in process
 	\li Cycle time
 	\li Costs
 	\li Shortages
 	\li Time in queue
 	\li Number in queue?
\ulE

\expl{Validierung}{Gültigkeitsüberprüfung}
\expl{Verifikation}{Beweis gegenüber formaler Spezifikation}


\se{Simulations Phasen}
\sse{Simulation Prozess I}
\img{img/v2.1.jpg}{}{0.75}{}
\ul
	\li Reales System ist komplex, magic, unverständlich
	\li Das Menschliche Gehirn modelliert immer
	\li Modellieren: Etwas so beschreiben, wie wir es beobachten in der Realität
	\li Gutes Modell: Parameteränderung bewirkt gleichen Effekt wie die Änderung in der Realität
\ulE

\sse{Simulation Prozess II}
\img{img/v2.2.jpg}{}{0.75}{}
\ul
	\li System muss isoliert werden, weil man nicht alle Parameter kennt.
	\li Nur so genau wie nötig!
	\li Prozessbeschreibung: 
		\ul
			\li Beschreibt Prozesslogik
			\li Beschreibt temporales Verhalten\\
				wie lange?
		\ulE
	\li Datenmaterial
		\ul
			\li hypothetisches: unzuverlässiger
			\li empirisches: möglicherweise unvollständig, dafür zuverlässiger
		\ulE
	\li Generalisierung: Mit den Formalen Daten und der formalen Prozessbeschreibung wird ein formal mathematisches Model gebaut.
	\li Resultat der Simulation kann erneut als Input für erneute Simuation mit optiierten Parametern verwendet werden
\ulE		

\sse{Modelling}
\definition{Prozess}{Akteur, kann Algorithmen ausführen}
\img{img/v2.3.jpg}{}{0.75}{}


\ch{Event driven Architecture EDA}
Ereignisgesteuerte Prozesse:
\ul
	\li erkennen und analysieren Ereignisse und reagieren darauf
	\li tauschen Nachrichten aus
	\li erzeugen neue Ereignisse, die an Partner versendet werden
	\li Aktivitäten werden durch Ereignisse ausgelöst
	\li die reale Welt is ereignisgetrieben.
\ulE

\se{Ereignis}
\expl{Ereignis}{definiert durch Typ und Attribute}
\ul
	\li Ereignisse zielen auf eine Zustandsänderung
	\li Technische Ereignisse: von Sensoren
	\li Systemereignisse: innerhalb eines Systems, bsp. IP Paketeingang
	\li Geschäftsereignisse: bsp. Vertragskündigung
\ulE

\img{img/v2.4.jpg}{}{0.25}{}
\ul
	\li Erkennen: von relevanten Infos der Domäne
	\li Verarbeiten: von Ereignissen versch. Quellen, analysieren, aggregieren und aufsplitten, korrelieren oder verwerfen und kategorisieren (clustern von Muster)\\
	\li Reagieren: schicken von Warnmeldungen, aufrufen von Anwendungsfunktionen, erzeugen weiterer Ereignisse
\ulE

\expl{Ereignissenke}{Kann auch Ereignisquelle sein.
	\img{img/v2.5.jpg}{}{0.5}{}
}

\sse{Kommunikationsmuster}
\ul
	\li synchron
	\li asynchron
\ulE

\sse{Repetition}
\ul
	\li Die meissten Ereignisse sind Eventgesteuert
	\li Ereignis kann andere Ereignisse auslösen
	\li EDA: Ereignisverarbeitungszyklus
	\li Clustern nach Muster von Ereignisströmen: z.B. erkennen von Fehlermuster \ra erkennen der Fehlerqueller
	\li Mediator: lose Kopplung zwischen Ereignisquelle und Senke \ra Ereignis muss gar nicht wissen, wo es hin muss \img{img/v2.5.jpg}{}{0.5}{}
	\li Neues Ereignis kann durch Mediator ausgelöst werden
	\li Ereignisgesteuerte System basieren meisst auf asynchroner Kommunikation
	\li Aus einer Asynchronen Kommunikation kann immer eine Synchrone gemacht werden
	\li Asyncrhone Kommunikationskomponenten: unabhängig, durch Kommunikationsprotokoll verbunden
	\li Unterschied zwischen Deadlock und Livelock: Bei Livelock lebt das Objekt und (re)agiert, kommt aber aus einer Schleife nicht mehr raus, Bei Deadlock wartet das Objekt unendlich
\ulE


\se{Observer Pattern}
\img{img/v3.1.jpg}{}{0.75}{}
\ul
	\li Observer Pattern: Public/Subscribe Interaction. Empfangende Komponenten melden sich bei Sender/Sendeverteiler an
\ulE

\se{Complex Event Processing}
\definition{CEP}{Complex Event Processing}
CEP:
\ul
	\li gleichzeitige, dynamische Verarbeitung von Ereignissen
	\li Berücksichtigt Beziehungen zwischen Ereignissen
\ulE

\definition{ESP}{Event Stream Processing}
ESP: Verarbeitung kontinuierlicher Ereignisströme
\img{img/v3.2.jpg}{ESP: Anhand von Regeln wird aufgrund des Ereignisstreams gehandelt}{0.75}{}

\examp{Ereignisbehandlung}{In den USA tobt ein Sturm, mehrere grosse Weizenunternehmen fusionieren und in Europa ein Krieg ausbricht \ra Weizenaktien kaufen, weil der Preis steigen wird}
\definition{Echtzeitfähigkeit}{Die Antwort kommt in einer vordefinierten Zeit oder zu einem definierten Zeitpunkt \ra wenn früher oder später die Antwort kommt: Falschzeit}

\img{img/v3.3.jpg}{Ereignisverarbeitung}{0.75}{}

\ul
	\li (+) genaue Abbildung eines Dynamischen Systems
	\li (+) starke entkopplung der Komponenten
	\li (+) Hohe Agilität
	\li (--) Redundanz \ra Inkonsistenz, Wartbarkeitsprobleme
	\li (--) Lokalisierung und Behebung von Fehlern \ra Zeit ist ein weiterer Freiheitsgrad == Fehlerquelle
	\li (--) Strukturiertes Testen von EDA ist schwierig
	\li (--) Schwereres Verständnis des Gesammtsystems
	\li (--) Häufige Änderung der Komponenten
	\li (--) Nachfolgen des Ereignisflusses schwierig
\ulE

\expl{Diskrete Zustandsänderung}{Gibt es nicht. Jede Zustandsänderung benötigt Zeit. Es ist nur eine Frage der Granularität.}
\examp{Beispiele für diskrete/kontinuierliche Wahrnehmung von Zustandübergängen}{Diskret: Airbag, Kontinuierlich: Crashtest}
\expl{Zeitkontinuierlichkeit}{Die reale Welt ist zeitkontinuierlich}

\se{Simulation und Zeit}
\ul
	\li Zwei Uhren: Reale Zeit, Modellzeit innerhalb des Systems
	\li Modellzeit wird durch Modelluhr formuliert \ra Simulationsuhr
	\li Simulationsuhr ist nicht kontinuierlich, sondern springt von Ereigniszeitpunkt zu Ereigniszeitpunkt
	\img{img/v3.4.jpg}{Modellzeit}{0.75}{}
	\li Treten zwei Ereignisse gleichzeitig ein, so werden die dazu gehörenden
Ereignis-routinen bzgl. der Simulationsuhr
		\ul
			\li gleichzeitig bearbeitet, wenn sie unterschiedliche/keine Ressourcen benutzen
			\li	sequenziell bearbeitet, wenn sie die gleiche Ressource benötigen
		\ulE
	\li Gleichzeitige Ereignisse werden sequentiell berechnet, die Modellzeit läuft währen dieser Zeit jedoch nicht und in der Simulation finden die Ereignisse somit gleichzeitig statt
	\li \expl{Gleichzeitige Ereignisse}{können sich nicht gegenseitig beeinflussen, gleichzeitige Prozesse jedoch schon.}
	\li Einzelne Ereignisse müssen nicht in der Reihenfolge erzeugt werden, in der sie abgearbeitet werden
\ulE

\img{img/v3.5.jpg}{Ereignisse und Ereignisroutinen}{0.75}{}

\se{Prozesse}
\img{img/v3.6.jpg}{Prozesse laufen zwischen zwei Ereignissen}{0.5}{}
\img{img/v3.7.jpg}{Unabhängige Prozesse}{0.5}{}
\img{img/v3.8.jpg}{Dualitätsprinzip}{0.5}{}
\ul
	\li Bei der Parallelisierung von Simulationsprozessen kann es Abhängigkeitsprobleme geben
	\li Lösungen: 
		\ul
			\li Zentrale Kontroll/Barriereinstanz
			\li Anschliessende Kontrolle mit Backtracking
		\ulE
\ulE

\se{Repetition}
\ul
	\li Wann bietet sich ein Eventgetriebenes Modell an? 
		\ul 
			\li Wenn das Interesse am Zustandswechsel und nicht am Übergang liegt. 
		\ulE
	\li Was ist der Unterschied zwischen Rechenzeit / Realer Zeit / Modelzeit / Simulationszeit
		\ul 
			\li Der Simulationsfortschritt läuft anhand der Simulationsuhr
			\li Im Eventgetriebenen Modell springt die Zeit von Event zu Event
			\li Parallelität bezieht sich immer auf die Modellzeit und nicht die Rechenzeit
		\ulE
	\li Parallele Prozesse können sich gegenseitig Beeinflussen. Methoden zum Feststellen von Beeinflussungen:
		\ul
			\li Optimistisches Verfahren: Annahme, dass es geht. Im Fehlerfall: Backtracking
			\li Pessimistisches Verfahren: Zentrale Kontroll/Barriereinstanz
		\ulE
\ulE


\ch{Modellierung von zeitlichem Verhalten mit Warteschlangen}
\img{img/v4.1.jpg}{}{0.75}{}
\img{img/v4.2.jpg}{}{0.75}{}

\ul
	\li Erinnerungsfreier Zufallsprozess: Was bereits passiert ist, hat keinen Einfluss auf aktuelle Ereignisse \ra Ereignisse werden unabhängig erzeugt
	\li M/M/1/$\infty$/$\infty$/fifo:
		\ul
			\li M:
			\li M:
			\li 1:
			\li $\infty$:
			\li $\infty$:
			\li fifo: 
		\ulE
\ulE

\sse{Simple Queue}
\ul
	\li \#Token werden durch Zeit geteilt \ra Arrival Rate Lamda
	\li Was hinten rausgeht: Durchsatz x
	\li System ist stabil, wenn Lamda=X
	\li Utilisation kann sich nur zwischen 0\% und 100\% bewegen
\ulE
\img{img/v4.3.jpg}{Simple Queue M/M/1 II}{1}{}
\img{img/v4.4.jpg}{Simple Queue M/M/1 III}{1}{}
\img{img/v4.5.jpg}{Läuft die Utilisation gegen 100\%, so läuft die Residenzzeit (Delay) gegen Unendlich. $R/S = \frac{1}{1-u}$}{0.75}{}

\ul
	\li Utilisation kann sich linear verhalten. 
	\li Die Residenzzeit erhöht sich jedoch nicht linear.
\ulE
\img{img/v4.6.jpg}{Twin Center: Parallelschaltung von 2 M/M/1 Queues. (Fehler in der Rechnung: Q=X*R statt XR}{1}{}
\img{img/v4.7.jpg}{Dual Server M/M/2 I}{1}{}
\exam{Aufgabe, bei der eine Näherung überprüft werden muss}
\expl{Auslastung}{Der Dual Server ist besser ausgelastet, weil bei einer vollen Warteschlange immer beide Prozesse ausgelastet sind. Beim Twin Center könnte ein Prozess nicht ausgelastet sein, obwohl Eregnisse anstehen.}

\img{img/v4.8.jpg}{Multi Single Server Queue M/M/n}{1}{}

\img{img/v4.9.jpg}{Feedback Center}{1}{}

\img{img/v4.10.jpg}{Closed Queueing Center: Keine Unbegrenzte Anzahl Tokens, Nur eine begrenzte Lebenszeit im System}{1}{}






\end{document}
